<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Christmas - Blink Blink Edition v1.2</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at center, #0f3d0f 0%, #001a00 100%); /* Christmas Green */
        font-family: 'Segoe UI', sans-serif;
      }
      #canvas-container {
        width: 100%;
        height: 100vh;
        display: block;
      }

      /* UI Center  */
      #ui-layer {
        position: absolute;
        bottom: 30px;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 100;
      }

      /* Guide text  */
      .guide {
        color: rgba(255, 255, 255, 0.6);
        font-size: 13px;
        margin-bottom: 20px;
        text-shadow: 0 2px 4px black;
      }

      button {
        pointer-events: auto;
        cursor: pointer;
        background: linear-gradient(to bottom, #d32f2f, #8b0000);
        color: #fff;
        border: 2px solid #ffd700;
        padding: 15px 50px;
        border-radius: 30px;
        font-weight: 800;
        font-size: 16px;
        box-shadow: 0 0 30px rgba(255, 0, 0, 0.6),
          0 0 60px rgba(255, 215, 0, 0.3);
        animation: pulse 1.5s infinite, buttonGlow 2s infinite;
      }
      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }
      @keyframes buttonGlow {
        0%,
        100% {
          box-shadow: 0 0 30px rgba(255, 0, 0, 0.6),
            0 0 60px rgba(255, 215, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 50px rgba(255, 0, 255, 0.6),
            0 0 80px rgba(0, 255, 255, 0.4);
        }
      }

      /* Camera Preview  */
      #camera-preview {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 120px;
        height: 90px;
        border: 2px solid rgba(255, 0, 0, 0.5);
        transform: scaleX(-1);
        opacity: 0.6;
        border-radius: 8px;
      }

      /*  */
      #copyright {
        position: absolute;
        bottom: 10px;
        right: 15px;
        color: rgba(255, 255, 255, 0.3);
        font-size: 12px;
        z-index: 100;
        font-family: sans-serif;
        pointer-events: none;
        font-style: italic;
      }

      #error-log {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        color: red;
        background: rgba(0, 0, 0, 0.8);
        z-index: 999;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <div id="error-log"></div>

    <!-- UI  -->
    <div id="ui-layer">
      <!--  -->
      <div class="guide">
        üñê <b>Open:</b> Explode &nbsp;|&nbsp; ü´∂ <b>Heart:</b> Love &nbsp;|&nbsp;
        ‚úä <b>Fist:</b> Tree
      </div>
      <button id="btnStart" onclick="startSystem()">START MAGIC ‚ú®</button>
    </div>
    <div id="canvas-container"></div>
    <video class="input_video" style="display: none"></video>
    <canvas id="camera-preview"></canvas>

    <script>
      // ==========================================
      // 1. RESOURCES CONFIG 
      // ==========================================
      const MUSIC_URL = './audio.mp3';
      let bgMusic = new Audio(MUSIC_URL);
      bgMusic.loop = true;
      bgMusic.volume = 1.0;

      const loader = new THREE.TextureLoader();
      const photoFiles = [
        './image1.JPG',
        './image2.jpeg',
        './image3.jpg',
        './image4.jpeg',
        './image5.JPG',
      ];
      const photoTextures = [];
      photoFiles.forEach((f, i) => (photoTextures[i] = loader.load(f)));

      // === RAINBOW COLORS FOR BLINK BLINK ===
      // === CHRISTMAS / WINTER COLORS ===
      const WINTER_COLORS = [
        new THREE.Color(0xffffff), // White (Snow)
        new THREE.Color(0xa5f2f3), // Ice Blue
        new THREE.Color(0x00bfff), // Deep Sky Blue
        new THREE.Color(0xffd700), // Gold
        new THREE.Color(0xff0000), // Red
      ];

      const CHRISTMAS_COLORS = [
        new THREE.Color(0xff0000), // Red
        new THREE.Color(0x00ff00), // Green
        new THREE.Color(0xffd700), // Gold
        new THREE.Color(0xffffff), // White
        new THREE.Color(0xff1493), // Pink
      ];

      function createCustomTexture(type) {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const cx = 64,
          cy = 64;

        if (type === 'gold_glow') {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 40);
          grd.addColorStop(0, '#FFFFFF');
          grd.addColorStop(0.2, '#FFFFE0');
          grd.addColorStop(0.5, '#FFD700');
          grd.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === 'red_light') {
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0, '#FFAAAA');
          grd.addColorStop(0.3, '#FF0000');
          grd.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        } else if (type === 'gift_red') {
          ctx.fillStyle = '#D32F2F';
          ctx.fillRect(20, 20, 88, 88);
          ctx.fillStyle = '#FFD700';
          ctx.fillRect(54, 20, 20, 88);
          ctx.fillRect(20, 54, 88, 20);
          ctx.strokeStyle = 'rgba(0,0,0,0.3)';
          ctx.lineWidth = 2;
          ctx.strokeRect(20, 20, 88, 88);
        } else if (type === 'rainbow_glow') {
          // New rainbow glow texture
          const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, 50);
          grd.addColorStop(0, '#FFFFFF');
          grd.addColorStop(0.3, '#FFFF00');
          grd.addColorStop(0.6, '#FF00FF');
          grd.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, 128, 128);
        }
        return new THREE.CanvasTexture(canvas);
      }

      const textures = {
        gold: createCustomTexture('gold_glow'),
        red: createCustomTexture('red_light'),
        gift: createCustomTexture('gift_red'),
        rainbow: createCustomTexture('rainbow_glow'),
      };

      // ==========================================
      // 2. SYSTEM CONFIG 
      // ==========================================
      const CONFIG = {
        goldCount: 2500, // Increased particles
        redCount: 400, // Increased particles
        giftCount: 200, // Increased particles
        rainbowCount: 500, // NEW: Rainbow particles
        explodeRadius: 65,
        photoOrbitRadius: 25,
        treeHeight: 70,
        treeBaseRadius: 35,
        blinkSpeed: 8, // NEW: Blink speed multiplier
        colorChangeSpeed: 3, // NEW: Color change speed
      };

      let scene, camera, renderer;
      let groupGold, groupRed, groupGift, groupRainbow;
      let photoMeshes = [];
      let titleMesh, starMesh, loveMesh;
      let sparkleParticles; // NEW: Extra sparkle particles

      let state = 'TREE';
      let selectedIndex = 0;
      let handX = 0.5;
      
      // Global Gesture Variables
      let lastHandX = null;
      let lastSwipeTime = 0;
      let zoomLevel = 1.0;

      // State Smoothing
      let pendingState = 'TREE';
      let stateHoldFrames = 0;
      const STATE_HOLD_THRESHOLD = 5; // Frames to hold before switching

      // ==========================================
      // 3. THREE.JS SYSTEM 
      // ==========================================
      function init3D() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x090a0f, 0.002);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        groupGold = createParticleSystem('gold', CONFIG.goldCount, 2.0);
        groupRed = createParticleSystem('red', CONFIG.redCount, 3.5);
        groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);
        groupGift = createParticleSystem('gift', CONFIG.giftCount, 3.0);
        
        // Snow System
        createSnowParticles();

        createSparkleParticles(); // NEW: Create extra sparkles
        createPhotos();
        createDecorations();
        animate();
      }

      function createParticleSystem(type, count, size) {
        const pPositions = [];
        const pExplodeTargets = [];
        const pTreeTargets = [];
        const pHeartTargets = [];
        const sizes = [];
        const phases = [];
        const colorIndices = []; // NEW: For rainbow effect

        for (let i = 0; i < count; i++) {
          // --- TREE  ---
          const h = Math.random() * CONFIG.treeHeight;
          const y = h - CONFIG.treeHeight / 2;
          let radiusRatio =
            type === 'gold' || type === 'rainbow'
              ? Math.sqrt(Math.random())
              : 0.9 + Math.random() * 0.1;
          const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
          const r = maxR * radiusRatio;
          const theta = Math.random() * Math.PI * 2;
          pTreeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));

          // --- EXPLODE  ---
          const u = Math.random();
          const v = Math.random();
          const phi = Math.acos(2 * v - 1);
          const lam = 2 * Math.PI * u;
          let radMult = type === 'gift' ? 1.2 : 1.0;
          const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * radMult;
          pExplodeTargets.push(
            rad * Math.sin(phi) * Math.cos(lam),
            rad * Math.sin(phi) * Math.sin(lam),
            rad * Math.cos(phi)
          );

          // --- SOFT HEART  ---
          const tHeart = Math.random() * Math.PI * 2;
          let hx = 16 * Math.pow(Math.sin(tHeart), 3);
          let hy =
            13 * Math.cos(tHeart) -
            5 * Math.cos(2 * tHeart) -
            2 * Math.cos(3 * tHeart) -
            Math.cos(4 * tHeart);

          const rFill = Math.pow(Math.random(), 0.3); // Soft fill 
          hx *= rFill;
          hy *= rFill;
          let hz = (Math.random() - 0.5) * 8 * rFill;

          const noise = 1.0;
          hx += (Math.random() - 0.5) * noise;
          hy += (Math.random() - 0.5) * noise;
          hz += (Math.random() - 0.5) * noise;

          const scaleH = 2.2;
          pHeartTargets.push(hx * scaleH, hy * scaleH + 5, hz);

          // --- INIT  ---
          pPositions.push(
            pTreeTargets[i * 3],
            pTreeTargets[i * 3 + 1],
            pTreeTargets[i * 3 + 2]
          );
          sizes.push(size);
          phases.push(Math.random() * Math.PI * 2);
          phases.push(Math.random() * Math.PI * 2);
          colorIndices.push(Math.floor(Math.random() * WINTER_COLORS.length));
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          'position',
          new THREE.Float32BufferAttribute(pPositions, 3)
        );
        geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        // Init colors with rainbow variety 
        const colors = new Float32Array(count * 3);
        const baseColor = new THREE.Color();

        if (type === 'gold') baseColor.setHex(0xffd700);
        else if (type === 'red') baseColor.setHex(0xff0000);
        else if (type === 'rainbow') baseColor.setHex(0xff00ff);
        else baseColor.setHex(0xffffff);

        for (let i = 0; i < count; i++) {
          if (type === 'rainbow') {
            // Assign random rainbow color
            const rc = WINTER_COLORS[colorIndices[i]];
            colors[i * 3] = rc.r;
            colors[i * 3 + 1] = rc.g;
            colors[i * 3 + 2] = rc.b;
          } else {
            colors[i * 3] = baseColor.r;
            colors[i * 3 + 1] = baseColor.g;
            colors[i * 3 + 2] = baseColor.b;
          }
        }
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        geo.userData = {
          tree: pTreeTargets,
          explode: pExplodeTargets,
          heart: pHeartTargets,
          phases: phases,
          baseColor: baseColor,
          baseSize: size,
          colorIndices: colorIndices, // NEW
        };

        const mat = new THREE.PointsMaterial({
          size: size,
          map: textures[type] || textures.gold,
          transparent: true,
          opacity: 1.0,
          vertexColors: true,
          blending:
            type === 'gift' ? THREE.NormalBlending : THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });

        const points = new THREE.Points(geo, mat);
        scene.add(points);
        return points;
      }

      // NEW: Create extra sparkle particles that float around
      function createSparkleParticles() {
        const count = 300;
        const positions = [];
        const colors = [];
        const sizes = [];

        for (let i = 0; i < count; i++) {
          // Random positions around the scene
          positions.push(
            (Math.random() - 0.5) * 150,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100
          );

          // Random rainbow colors
          const color =
            WINTER_COLORS[Math.floor(Math.random() * WINTER_COLORS.length)];
          colors.push(color.r, color.g, color.b);
          sizes.push(1 + Math.random() * 2);
        }

        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          'position',
          new THREE.Float32BufferAttribute(positions, 3)
        );
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        geo.userData = {
          velocities: positions.map(() => ({
            x: (Math.random() - 0.5) * 0.3,
            y: (Math.random() - 0.5) * 0.3,
            z: (Math.random() - 0.5) * 0.3,
          })),
          phases: positions.map(() => Math.random() * Math.PI * 2),
        };

        const mat = new THREE.PointsMaterial({
          size: 2,
          map: textures.gold,
          transparent: true,
          opacity: 0.8,
          vertexColors: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });

        sparkleParticles = new THREE.Points(geo, mat);
        scene.add(sparkleParticles);
      }

      // NEW: FALLING SNOW PARTICLES
      let snowSystem;
      function createSnowParticles() {
        const particleCount = 1000;
        const geo = new THREE.BufferGeometry();
        const positions = [];
        const velocities = [];
        
        for (let i = 0; i < particleCount; i++) {
            positions.push(
                (Math.random() - 0.5) * 200, // x
                Math.random() * 100,         // y
                (Math.random() - 0.5) * 100  // z
            );
            velocities.push(
                (Math.random() - 0.5) * 0.2, // x velocity (wind)
                -(Math.random() * 0.5 + 0.2) // y velocity (fall)
            );
        }
        
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        // Snowflake texture
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grd.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, 32, 32);
        const tex = new THREE.CanvasTexture(canvas);

        const mat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            map: tex,
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        snowSystem = new THREE.Points(geo, mat);
        snowSystem.userData = { velocities: velocities };
        scene.add(snowSystem);
      }

      function updateSnow() {
        if(!snowSystem) return;
        const positions = snowSystem.geometry.attributes.position.array;
        const velocities = snowSystem.userData.velocities;
        
        for(let i = 0; i < positions.length / 3; i++) {
            // Apply velocity
            positions[i*3] += velocities[i*2];   // x
            positions[i*3+1] += velocities[i*2+1]; // y
            
            // Reset if below floor
            if(positions[i*3+1] < -60) {
                positions[i*3+1] = 60;
                positions[i*3] = (Math.random() - 0.5) * 200;
            }
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
        snowSystem.rotation.y += 0.001; // Global rotation
      }

      function createPhotos() {
        const geo = new THREE.PlaneGeometry(8, 8);
        const borderGeo = new THREE.PlaneGeometry(9, 9);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });

        for (let i = 0; i < 5; i++) {
          const mat = new THREE.MeshBasicMaterial({
            map: photoTextures[i],
            side: THREE.DoubleSide,
          });
          const mesh = new THREE.Mesh(geo, mat);
          const border = new THREE.Mesh(borderGeo, borderMat);
          border.position.z = -0.1;
          mesh.add(border);
          mesh.visible = false;
          mesh.scale.set(0, 0, 0);
          scene.add(mesh);
          photoMeshes.push(mesh);
        }
      }

      function createDecorations() {
        // MERRY CHRISTMAS  - Enhanced with rainbow glow
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');

        // Rainbow gradient text
        const gradient = ctx.createLinearGradient(0, 0, 1024, 0);
        gradient.addColorStop(0, '#FF0000');
        gradient.addColorStop(0.17, '#FF7F00');
        gradient.addColorStop(0.33, '#FFFF00');
        gradient.addColorStop(0.5, '#00FF00');
        gradient.addColorStop(0.67, '#00FFFF');
        gradient.addColorStop(0.83, '#FF00FF');
        gradient.addColorStop(1, '#FF0000');

        ctx.font = 'bold italic 70px "Times New Roman"';
        ctx.fillStyle = gradient;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#FF00FF';
        ctx.shadowBlur = 50;
        ctx.fillText('Merry Christmas Nhat Anh', 512, 130);

        // Add extra glow
        ctx.shadowColor = '#00FFFF';
        ctx.shadowBlur = 30;
        ctx.fillText('Merry Christmas Nhat Anh', 512, 130);

        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), mat);
        titleMesh.position.set(0, 50, 0);
        scene.add(titleMesh);

        // STAR  - Enhanced with more glow
        const starCanvas = document.createElement('canvas');
        starCanvas.width = 128;
        starCanvas.height = 128;
        const sCtx = starCanvas.getContext('2d');

        // Multiple color layers for extra glow
        const starColors = ['#FF00FF', '#FFFF00', '#00FFFF', '#FFFFFF'];
        const cx = 64,
          cy = 64,
          outer = 50,
          inner = 20;

        starColors.forEach((color, idx) => {
          sCtx.fillStyle = color;
          sCtx.shadowColor = color;
          sCtx.shadowBlur = 30 - idx * 5;
          sCtx.beginPath();
          for (let i = 0; i < 5; i++) {
            sCtx.lineTo(
              cx +
                Math.cos(((18 + i * 72) / 180) * Math.PI) * (outer - idx * 3),
              cy - Math.sin(((18 + i * 72) / 180) * Math.PI) * (outer - idx * 3)
            );
            sCtx.lineTo(
              cx +
                Math.cos(((54 + i * 72) / 180) * Math.PI) * (inner - idx * 2),
              cy - Math.sin(((54 + i * 72) / 180) * Math.PI) * (inner - idx * 2)
            );
          }
          sCtx.closePath();
          sCtx.fill();
        });

        const starTex = new THREE.CanvasTexture(starCanvas);
        const starMat = new THREE.MeshBasicMaterial({
          map: starTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        starMesh = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), starMat);
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 2, 0);
        scene.add(starMesh);

        // I LOVE YOU TEXT  - Enhanced with rainbow
        const loveCanvas = document.createElement('canvas');
        loveCanvas.width = 1024;
        loveCanvas.height = 256;
        const lCtx = loveCanvas.getContext('2d');

        // Rainbow gradient for love text
        const loveGradient = lCtx.createLinearGradient(0, 0, 1024, 0);
        loveGradient.addColorStop(0, '#FF1493');
        loveGradient.addColorStop(0.25, '#FF69B4');
        loveGradient.addColorStop(0.5, '#FF0000');
        loveGradient.addColorStop(0.75, '#FF69B4');
        loveGradient.addColorStop(1, '#FF1493');

        lCtx.font = 'bold 120px "Segoe UI", sans-serif';
        lCtx.fillStyle = loveGradient;
        lCtx.textAlign = 'center';
        lCtx.shadowColor = '#FF1493';
        lCtx.shadowBlur = 50;
        lCtx.fillText('I LOVE YOU ‚ù§Ô∏è', 512, 130);

        const loveTex = new THREE.CanvasTexture(loveCanvas);
        const loveMat = new THREE.MeshBasicMaterial({
          map: loveTex,
          transparent: true,
          blending: THREE.AdditiveBlending,
        });
        loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), loveMat);
        loveMesh.position.set(0, 0, 20);
        loveMesh.visible = false;
        scene.add(loveMesh);
      }

      // NEW: HSL color helper for smooth rainbow transitions
      function hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r, g, b };
      }

      function updateParticleGroup(
        group,
        type,
        targetState,
        speed,
        handRotY,
        time
      ) {
        const positions = group.geometry.attributes.position.array;
        const sizes = group.geometry.attributes.size.array;
        const colors = group.geometry.attributes.color.array;
        const phases = group.geometry.userData.phases;
        const baseColor = group.geometry.userData.baseColor;
        const baseSize = group.geometry.userData.baseSize;
        const colorIndices = group.geometry.userData.colorIndices;

        const targetKey =
          targetState === 'TREE'
            ? 'tree'
            : targetState === 'HEART'
            ? 'heart'
            : 'explode';
        const targets =
          group.geometry.userData[
            targetState === 'PHOTO' ? 'explode' : targetKey
          ];

        // 1. Position update 
        for (let i = 0; i < positions.length; i++) {
          positions[i] += (targets[i] - positions[i]) * speed;
        }
        group.geometry.attributes.position.needsUpdate = true;

        // 2. COLOR & SIZE with BLINK BLINK 
        const count = positions.length / 3;

        if (targetState === 'TREE') {
          group.rotation.y += 0.003;

          for (let i = 0; i < count; i++) {
            // Enhanced blink effect with multiple frequencies
            const blink1 = Math.sin(time * CONFIG.blinkSpeed + phases[i]);
            const blink2 = Math.sin(
              time * CONFIG.blinkSpeed * 1.7 + phases[i] * 2
            );
            const blink3 = Math.sin(
              time * CONFIG.blinkSpeed * 0.5 + phases[i] * 0.5
            );

            // Size pulsing - more dramatic
            const sizePulse = 0.6 + 0.6 * Math.abs(blink1);
            sizes[i] = baseSize * sizePulse;

            if (type === 'rainbow') {
              // Rainbow cycling through colors
              const hue = (time * 0.1 + phases[i] / Math.PI) % 1;
              const rgb = hslToRgb(hue, 1, 0.5 + 0.3 * blink1);
              colors[i * 3] = rgb.r;
              colors[i * 3 + 1] = rgb.g;
              colors[i * 3 + 2] = rgb.b;
            } else if (type === 'red') {
              // Red with color shifting to orange/pink
              const brightness = 0.5 + 0.5 * Math.abs(blink1);
              const shift = blink2 * 0.3;
              colors[i * 3] = Math.min(1, baseColor.r * brightness + shift);
              colors[i * 3 + 1] =
                baseColor.g * brightness + Math.max(0, shift * 0.5);
              colors[i * 3 + 2] =
                baseColor.b * brightness + Math.max(0, shift * 0.3);
            } else if (type === 'gold') {
              // Gold with shimmer effect shifting to white/orange
              const brightness = 0.7 + 0.5 * Math.abs(blink1);
              const shimmer = (blink2 + 1) * 0.3;
              colors[i * 3] = Math.min(1, baseColor.r * brightness);
              colors[i * 3 + 1] = Math.min(
                1,
                baseColor.g * brightness + shimmer * 0.2
              );
              colors[i * 3 + 2] = Math.min(
                1,
                baseColor.b * brightness + shimmer * 0.5
              );
            } else {
              // Gift particles - Christmas color cycling
              const colorIdx = Math.floor(
                (time * CONFIG.colorChangeSpeed + phases[i]) %
                  CHRISTMAS_COLORS.length
              );
              const nextIdx = (colorIdx + 1) % CHRISTMAS_COLORS.length;
              const blend = (time * CONFIG.colorChangeSpeed + phases[i]) % 1;

              const c1 = CHRISTMAS_COLORS[colorIdx];
              const c2 = CHRISTMAS_COLORS[nextIdx];
              colors[i * 3] = c1.r + (c2.r - c1.r) * blend;
              colors[i * 3 + 1] = c1.g + (c2.g - c1.g) * blend;
              colors[i * 3 + 2] = c1.b + (c2.b - c1.b) * blend;
            }
          }
          group.geometry.attributes.color.needsUpdate = true;
          group.geometry.attributes.size.needsUpdate = true;
        } else if (targetState === 'HEART') {
          group.rotation.y = 0;
          const beatScale = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
          group.scale.set(beatScale, beatScale, beatScale);

          // Heart mode - romantic pink/red colors with sparkle
          for (let i = 0; i < count; i++) {
            const sparkle = Math.sin(time * 15 + phases[i]) * 0.5 + 0.5;

            if (type === 'rainbow') {
              // Rainbow hearts
              const hue = (time * 0.2 + phases[i] / Math.PI) % 1;
              const rgb = hslToRgb(hue, 1, 0.5 + 0.3 * sparkle);
              colors[i * 3] = rgb.r;
              colors[i * 3 + 1] = rgb.g;
              colors[i * 3 + 2] = rgb.b;
            } else {
              // Pink/red gradient
              colors[i * 3] = 1.0;
              colors[i * 3 + 1] = 0.2 + sparkle * 0.4;
              colors[i * 3 + 2] = 0.4 + sparkle * 0.4;
            }

            if (i % 3 === 0) sizes[i] = baseSize * (0.8 + sparkle * 0.4);
            else sizes[i] = 0;
          }
          group.geometry.attributes.color.needsUpdate = true;
          group.geometry.attributes.size.needsUpdate = true;
        } else {
          // EXPLODE - Maximum blink blink mode!
          group.scale.set(1, 1, 1);
          group.rotation.y += (handRotY - group.rotation.y) * 0.1;

          for (let i = 0; i < count; i++) {
            // Multi-frequency blink for disco effect
            const disco1 = Math.sin(time * 12 + phases[i]);
            const disco2 = Math.cos(time * 8 + phases[i] * 1.5);
            const disco3 = Math.sin(time * 20 + phases[i] * 0.7);

            // Dramatic size changes
            sizes[i] = baseSize * (0.5 + 0.8 * Math.abs(disco1 * disco2));

            if (type === 'rainbow') {
              // Fast rainbow cycling
              const hue = (time * 0.5 + phases[i] / Math.PI) % 1;
              const rgb = hslToRgb(hue, 1, 0.5 + 0.4 * disco3);
              colors[i * 3] = rgb.r;
              colors[i * 3 + 1] = rgb.g;
              colors[i * 3 + 2] = rgb.b;
            } else if (type === 'gold' || type === 'red') {
              // Color shifting disco effect
              const colorShift = (disco1 + disco2) * 0.5;
              const brightness = 0.6 + 0.6 * Math.abs(disco3);

              if (colorShift > 0.3) {
                // Shift towards cyan/blue
                colors[i * 3] = baseColor.r * brightness * 0.5;
                colors[i * 3 + 1] = brightness;
                colors[i * 3 + 2] = brightness;
              } else if (colorShift < -0.3) {
                // Shift towards magenta
                colors[i * 3] = brightness;
                colors[i * 3 + 1] = baseColor.g * brightness * 0.3;
                colors[i * 3 + 2] = brightness;
              } else {
                // Original color with brightness
                colors[i * 3] = baseColor.r * brightness;
                colors[i * 3 + 1] = baseColor.g * brightness;
                colors[i * 3 + 2] = baseColor.b * brightness;
              }
            } else {
              // Gift - full rainbow
              const hue = (time * 0.3 + phases[i] / Math.PI) % 1;
              const rgb = hslToRgb(hue, 0.9, 0.6);
              colors[i * 3] = rgb.r;
              colors[i * 3 + 1] = rgb.g;
              colors[i * 3 + 2] = rgb.b;
            }
          }
          group.geometry.attributes.size.needsUpdate = true;
          group.geometry.attributes.color.needsUpdate = true;
        }
      }

      // NEW: Update sparkle particles
      function updateSparkleParticles(time) {
        if (!sparkleParticles) return;

        const positions = sparkleParticles.geometry.attributes.position.array;
        const colors = sparkleParticles.geometry.attributes.color.array;
        const sizes = sparkleParticles.geometry.attributes.size.array;
        const velocities = sparkleParticles.geometry.userData.velocities;
        const phases = sparkleParticles.geometry.userData.phases;

        const count = positions.length / 3;

        for (let i = 0; i < count; i++) {
          // Move particles
          positions[i * 3] += velocities[i].x;
          positions[i * 3 + 1] += velocities[i].y;
          positions[i * 3 + 2] += velocities[i].z;

          // Wrap around boundaries
          if (positions[i * 3] > 75) positions[i * 3] = -75;
          if (positions[i * 3] < -75) positions[i * 3] = 75;
          if (positions[i * 3 + 1] > 50) positions[i * 3 + 1] = -50;
          if (positions[i * 3 + 1] < -50) positions[i * 3 + 1] = 50;
          if (positions[i * 3 + 2] > 50) positions[i * 3 + 2] = -50;
          if (positions[i * 3 + 2] < -50) positions[i * 3 + 2] = 50;

          // Rainbow color cycling
          const hue = (time * 0.2 + phases[i] / Math.PI) % 1;
          const rgb = hslToRgb(
            hue,
            1,
            0.5 + 0.3 * Math.sin(time * 10 + phases[i])
          );
          colors[i * 3] = rgb.r;
          colors[i * 3 + 1] = rgb.g;
          colors[i * 3 + 2] = rgb.b;

          // Size blinking
          sizes[i] = 1 + 2 * Math.abs(Math.sin(time * 8 + phases[i]));
        }

        sparkleParticles.geometry.attributes.position.needsUpdate = true;
        sparkleParticles.geometry.attributes.color.needsUpdate = true;
        sparkleParticles.geometry.attributes.size.needsUpdate = true;

        // Gentle rotation
        sparkleParticles.rotation.y += 0.001;
      }

      function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        const speed = 0.08;
        const handRotY = (handX - 0.5) * 4.0;

        updateParticleGroup(groupGold, 'gold', state, speed, handRotY, time);
        updateParticleGroup(groupRed, 'red', state, speed, handRotY, time);
        updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);
        updateParticleGroup(groupGift, 'gift', state, speed, handRotY, time);
        // groupRainbow removed/replaced by Snow
        /* updateParticleGroup(
          groupRainbow,
          'rainbow',
          state,
          speed,
          handRotY,
          time
        ); */
        updateSparkleParticles(time); 
        updateSnow(); // Update snow physics

        photoMeshes.forEach((mesh, i) => {
          if (!mesh.material.map && photoTextures[i]) {
            mesh.material.map = photoTextures[i];
            mesh.material.needsUpdate = true;
          }
        });

        if (state === 'TREE') {
          titleMesh.visible = true;
          starMesh.visible = true;
          loveMesh.visible = false;
          titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);

          // Enhanced star animation with color cycling
          starMesh.rotation.z -= 0.03;
          starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);

          // Star color pulsing
          const starPulse = 0.8 + 0.2 * Math.sin(time * 3);
          starMesh.scale.set(starPulse, starPulse, starPulse);

          photoMeshes.forEach((m) => {
            m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            m.visible = false;
          });
        } else if (state === 'HEART') {
          titleMesh.visible = false;
          starMesh.visible = false;
          loveMesh.visible = true;
          photoMeshes.forEach((m) => {
            m.visible = false;
          });
          const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
          loveMesh.scale.set(s, s, 1);

          // Love text color cycling
          loveMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 4);
        } else if (state === 'EXPLODE') {
          titleMesh.visible = false;
          starMesh.visible = false;
          loveMesh.visible = false;
          const baseAngle = groupGold.rotation.y;
          const angleStep = (Math.PI * 2) / 5;
          let bestIdx = 0;
          let maxZ = -999;
          photoMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = baseAngle + i * angleStep;
            const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
            const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
            const y = Math.sin(time + i) * 3;
            mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            mesh.lookAt(camera.position);
            if (z > maxZ) {
              maxZ = z;
              bestIdx = i;
            }
            if (z > 5) {
              const ds = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
              mesh.scale.lerp(new THREE.Vector3(ds, ds, ds), 0.1);
            } else {
              mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
            }
          });
          selectedIndex = bestIdx;
        } else if (state === 'PHOTO') {
          loveMesh.visible = false;
          photoMeshes.forEach((mesh, i) => {
            if (i === selectedIndex) {
              mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
              const targetScale = 5 * zoomLevel; // Apply Zoom
              mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
              mesh.lookAt(camera.position);
              mesh.rotation.z = 0;
            } else {
              mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
          });
        }
        renderer.render(scene, camera);
      }

      function startSystem() {
        document.getElementById('btnStart').style.display = 'none';
        bgMusic.play().catch((e) => console.log(e));
        init3D();

        const video = document.getElementsByClassName('input_video')[0];
        const canvas = document.getElementById('camera-preview');
        const ctx = canvas.getContext('2d');

        const hands = new Hands({
          locateFile: (file) =>
            `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });
        hands.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        // Global variables are now at top of script

        hands.onResults((results) => {
          ctx.clearRect(0, 0, 100, 75);
          ctx.drawImage(results.image, 0, 0, 100, 75);

          // 1. Two Hands Logic (Heart & Zoom)
          if (results.multiHandLandmarks.length === 2) {
            const h1 = results.multiHandLandmarks[0];
            const h2 = results.multiHandLandmarks[1];
            
            // HEART GESTURE (Index + Thumb touching between hands)
            const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
            const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
            
            // RELAXED THRESHOLDS (Easier to trigger)
            // Heart: < 0.25 (was 0.2)
            if (distIndex < 0.25 && distThumb < 0.25) { 
                if(pendingState !== 'HEART') {
                    pendingState = 'HEART';
                    stateHoldFrames = 0;
                } else {
                    stateHoldFrames++;
                    if(stateHoldFrames > STATE_HOLD_THRESHOLD) state = 'HEART';
                }
                return;
            }

            // ZOOM GESTURE (Distance between wrists)
            if (state === 'PHOTO') {
                const distWrists = Math.hypot(h1[0].x - h2[0].x, h1[0].y - h2[0].y);
                zoomLevel = 1.0 + (Math.max(0, distWrists - 0.2) * 4);
                return;
            }
          } else {
              zoomLevel = 1.0; 
          }

          let detectedState = 'TREE'; // Default if no hands

          // 2. Single Hand Logic
          if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const currentHandX = lm[9].x; 
            handX = currentHandX;

            // ... Swipe Logic remains same ...
            const now = Date.now();
            if (lastHandX !== null && (now - lastSwipeTime > 500)) {
                const deltaX = currentHandX - lastHandX;
                if (deltaX > 0.15) { 
                    lastSwipeTime = now;
                    selectedIndex = (selectedIndex - 1 + 5) % 5;
                } else if (deltaX < -0.15) { 
                    lastSwipeTime = now;
                    selectedIndex = (selectedIndex + 1) % 5;
                }
            }
            lastHandX = currentHandX;

            // GESTURE CLASSIFICATION
            // GESTURE CLASSIFICATION - GEOMETRIC APPROACH
            // Check if fingers are curled by comparing Tip-Wrist dist vs PIP-Wrist dist
            // Fingers: Index(8), Middle(12), Ring(16), Pinky(20). (Thumb is special)
            const tips = [8, 12, 16, 20];
            const fingerPIPs = [6, 10, 14, 18];
            let foldedCount = 0;
            
            for(let i=0; i<4; i++) {
                const tip = lm[tips[i]];
                const pip = lm[fingerPIPs[i]];
                const wrist = lm[0];
                
                const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
                
                // If Tip is closer to wrist than PIP (Knuckle), it's folded
                if (dTip < dPip) {
                    foldedCount++;
                }
            }

            const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);

            // LOGIC:
            // 1. PINCH: Thumb & Index close (<0.08)
            // 2. TREE (Fist): At least 3 fingers folded
            // 3. EXPLODE (Open): < 2 fingers folded
            
            if (pinchDist < 0.08) {
              detectedState = 'PHOTO';
              
              // Only apply single hand zoom if 1 hand.
              // Measure distance from Wrist(0) to Middle Finger MCP(9) as proxy for depth/scale
              const handScale = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
              if(results.multiHandLandmarks.length === 1) {
                  zoomLevel = 1.0 + (Math.max(0, handScale - 0.15) * 6); 
              }

            } else if (foldedCount >= 3) {
              detectedState = 'TREE';
            } else {
              detectedState = 'EXPLODE';
            }
          }

          // Apply Debounce/Smoothing
          if (detectedState !== pendingState) {
              pendingState = detectedState;
              stateHoldFrames = 0;
          } else {
              stateHoldFrames++;
              if (stateHoldFrames > STATE_HOLD_THRESHOLD) {
                  state = detectedState;
              }
          }
        });

        const cameraUtils = new Camera(video, {
          onFrame: async () => {
            await hands.send({ image: video });
          },
          width: 320,
          height: 240,
        });
        cameraUtils.start();
      }

      window.addEventListener('resize', () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
